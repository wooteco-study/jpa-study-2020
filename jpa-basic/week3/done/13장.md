# 13장. 웹 애플리케이션과 영속성 관리

## 13.1 트랜젝션 범위의 영속성 컨텍스트

### 13.1.1 스프링 컨테이너의 기본 전략

- 스프링 컨테이너는 **트랜젝션 범위의 영속성 컨텍스트** 전략을 기본으로 사용한다.
- 트랜젝션의 범위와 영속성 컨텍스트의 생존 범위가 같다
- 트랜젝션을 시작할 때 영속성 컨텍스트를 생성하고 트랜젝션이 끝날 때 영속성 컨텍스트를 종료한다.
- 같은 트랜젝션 안에서는 항상 같은 영속성 컨텍스트에 접근한다.
- @Transactional 어노테이션이 붙은 메서드가 실행될 때 트랜젝션이 시작된다.
    - 메서드가 정상적으로 종료되면 트랜젝션을 커밋하면서 트랜젝션을 종료한다.
    - 트랜젝션을 커밋하면 JPA가 먼저 영속성 컨텍스트를 플러시해서 변경내용을 DB에 반영한 후에 트랜젝션을 커밋한다.
- 예외가 발생하면 트랜젝션을 롤백하고 종료하고, 이때는 플러시가 호출되지 않는다.
- 트랜젝션이 다르면 다른 영속성 컨텍스트를 사용한다.
    - 스프링 컨테이너는 스레드마다 각각 다른 트랜젝션을 할당하고, 각 스레드마다 접근하는 영속성 컨텍스트가 다르므로 멀티스레드 상황에서 안전하다.

## 13.2 준영속 상태와 지연 로딩

- 보통 서비스 계층에서 트랜젝션을 시작하므로 서비스 계층이 끝나는 시점에 트랜젝션이 종료되면서 영속성 컨텍스트도 종료된다.
    - 그래서 프리젠테이션 계층에서는 엔티티가 준영속 상태이다.
    - 프리젠테이션 계층에서는 변경 감지와 지연 로딩이 동작하지 않는다.
- 프리젠테이션 계층에서 준영속 상태의 엔티티의 지연 로딩이 동작하지 않는 문제의 해결방법은 2가지이다.
    - 뷰가 필요한 엔티티를 미리 로딩
        - 글로벌 페치 전략 수정
            - 글로벌 페치 전략을 즉시 로딩 (fetch = FetchType.EAGER) 전략으로 수정한다.
            - 뷰에 따라 필요한 엔티티가 다르기 때문에, 사용하지 않는 엔티티를 로딩할 수 있는 단점이 있다.
            - JPQL을 사용하면 N+1 문제가 발생할 수 있다.
                - em.find() 메서드로 조회하면 연관된 엔티티를 join 쿼리로 함께 조회해서 문제가 없다.
                - JPQL을 사용하면 글로벌 페치 전략을 참고하지 않고 오직 작성한 JPQL 쿼리만 사용한다.
                - 그 후에 글로벌 페치 전략을 참고해(즉시 로딩) 연관된 엔티티를 조회하는 쿼리를 사용한다.
                - 이 때, JPQL 쿼리로 조회된 엔티티의 개수만큼의 연관된 엔티티를 조회하는 쿼리가 사용된다.
                - 쿼리가 상당히 많이 호출될 수 있어서 조회 성능에 문제가 될 가능성이 크다.
        - JPQL fetch join
            - JPQL을 호출하는 시점에 함께 로딩할 엔티티를 선택할 수 있다.
            - fetch join 사용안한 JPQL : select o from Order o
            - fetch join 사용한 JPQL : select o from Order o join fetch o.member
            - join을 사용해서 fetch join 대상까지 한번에 조회해서 N+1문제가 발생하지 않는다.
            - 뷰에 맞춘 repository의 메서드가 증가해서 프리젠테이션 계층과 데이터 접근 계층에 의존관계가 생기게 된다.
        - 강제로 초기화
            - 영속성 컨텍스트가 살아있어서 엔티티가 영속 상태일 때, 필요한 엔티티를 강제로 초기화하는 방법이다.
            - 프록시를 초기화하는 역할을 서비스 계층이 담당하면, 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 수정해야한다.
            - 서비스 계층과 프리젠테이션의 계층의 의존관계가 생긴다.
            - 프리젠테이션 계층과 서비스 계층 사이에 FACADE 계층을 추가해서 FACADE 계층이 프록시 초기화 역할을 하도록 할 수 있다.
    - OSIV를 사용해서 엔티티를 항상 영속 상태로 유지

## 13.3 OSIV

영속성 컨텍스트를 뷰까지 열어두는 것이다. 영속성 컨텍스트가 살아 있으면 엔티티는 영속 상태이므로 뷰에서도 지연 로딩을 할 수 있다.

### 13.3.1 과거 OSIV : 요청 당 트랜젝션

- 클라이언트 요청이 들어오면 서블릿 필터나 스프링 인터셉터에서 트랜젝션을 시작하고 요청이 끝나면 트랜젝션도 끝낸다.
- 프리젠테이션 계층에서 엔티티를 변경할 수 있는 단점이 있다.
    - 프리젠테이션 계층에서 엔티티를 수정하지 못하게 막는 방법들
        - 엔티티를 읽기 전용 인터페이스로 제공
            - getter 메서드만 있는 인터페이스를 사용하는 방법
        - 엔티티 래핑
            - 엔티티를 필드로 갖고 있으면서 읽기 전용 메서드만 제공하는 래퍼 클래스를 사용하는 방법
        - DTO만 반환
            - OSIV의 장점을 살릴 수 없다
- 위와 같은 단점으로 요청 당 트랜젝션 방식의 OSIV는 최근에는 거의 사용하지 않는다.

### 13.3.2 스프링 OSIV : 비즈니스 계층 트랜젝션

- 서블릿 필터에 OSIV를 적용하려면 OpenSessionInViewFilter 를 서블릿 필터에 등록
- 스프링 인터셉터에 OSIV를 적용하려면 OPenSessionInViewInterceptor 를 스프링 인터셉터에 등록

트랜젝션은 비즈니스 계층에서만 사용한다.

- 클라이언트 요청이 들어오면 영속성 컨텍스트를 생성하고, 트랜젝션은 시작하지 않는다.
- 서비스 계층에서 트랜젝션을 시작하면 생성해둔 영속성 컨텍스트에 트랜젝션을 시작한다.
- 서비스 계층이 끝나면 트랜젝션을 커밋하면서 영속성 컨텍스트를 플러시한다.
- 트랜젝션만 종료하고 영속성 컨텍스트는 살려둔다.
- 클라이언트의 요청이 끝나면 영속성 컨텍스트를 종료한다.

트랜젝션 없이 읽기

- 엔티티를 변경하지 않고 단순히 조회만 할 때는 트랜젝션이 없어도 된다.
- 프록시를 초기화하는 지연 로딩도 조회 기능이므로 트랜젝션 없이 읽기가 가능하다.

프리젠테이션 계층에서 엔티티를 수정한 후에 트랜젝션을 시작하는 서비스 계층의 메서드를 호출하면 프리젠테이션 계층에서 수정한 내용이 DB에 반영 될 수 있다.

트랜젝션이 있는 비즈니스 로직을 모두 호출하고 나서 엔티티를 변경해야 한다.

스프링 OSIV의 특징

- OSIV는 클라이언트의 요청이 들어올 때 영속성 컨텍스트를 생성해서 요청이 끝날 때까지 영속상태를 유지한다.
- 엔티티 수정은 트랜젝션이 있는 계층에서만 동작한다. 트랜젝션이 없는 프리젠테이션 계층은 지연로딩을 포함해서 조회만 할 수 있다.

스프링 OSIV의 단점

- OSIV를 적용하면 같은 영속성 컨텍스트를 여러 트랜젝션이 공유할 수 있다
- 프리젠테이션 계층에서 엔티티를 수정하고나서 비즈니스 로직을 수행하면 엔티티가 수정될 수 있다.
- 프리젠테이션 계층에서 지연 로딩에 의해 쿼리가 수행되므로, 성능 튜닝시에 확인해야할 포인트가 넓어진다.